#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# SPDX-FileCopyrightText: 2021 Robin Schneider <robin.schneider@geberit.com>
#
# SPDX-License-Identifier: AGPL-3.0-only

"""
POC to read vector.dev config and create a PlantUML deployment diagram.
https://plantuml.com/deployment-diagram

You might also find `vector graph` helpful. gen_component_diagram was written a
few days before `vector graph` was released and I learned about it.
"""

import argparse
import collections
import fnmatch
import copy

import yaml

__version__ = '0.1.0'


def dict_merge(dct, merge_dct):
    """ Recursive dict merge. Inspired by :meth:``dict.update()``, instead of
    updating only top-level keys, dict_merge recurses down into dicts nested
    to an arbitrary depth, updating keys. The ``merge_dct`` is merged into
    ``dct``.
    :param dct: dict onto which the merge is executed
    :param merge_dct: dct merged into dct
    :return: None
    """
    for k, v in merge_dct.items():
        if (k in dct and isinstance(dct[k], dict)
                and isinstance(merge_dct[k], collections.Mapping)):
            dict_merge(dct[k], merge_dct[k])
        else:
            dct[k] = merge_dct[k]


def main():
    args_parser = argparse.ArgumentParser(description=__doc__)
    args_parser.add_argument('-c', '--config', required=True, nargs='+')
    args_parser.add_argument(
        '-V', '--version', action='version',
        version='%(prog)s {}'.format(__version__))
    cli_args = args_parser.parse_args()

    config = {}

    for yaml_filepath in cli_args.config:
        with open(yaml_filepath, 'r') as yaml_fh:
            dict_merge(config, yaml.safe_load(yaml_fh))

    print("@startuml")
    print("' The following is generated by gen_component_diagram, all changes will be lost.")
    print("left to right direction")
    print("skinparam linetype ortho")

    components = {}

    for component_name, component in config.get('sources', {}).items():
        components[component_name] = component
        components[component_name]['component_kind'] = 'source'
    for component_name, component in config.get('transforms', {}).items():
        components[component_name] = component
        components[component_name]['component_kind'] = 'transform'
        if component['type'] == 'route':
            for route in list(component['route'].keys()) + ['_unmatched']:
                component_route_id = component_name + "." + route
                components[component_route_id] = copy.deepcopy(component)
                components[component_route_id]['component_kind'] = 'transform'
                components[component_route_id]['inputs'] = []
    for component_name, component in config.get('sinks', {}).items():
        components[component_name] = component
        components[component_name]['component_kind'] = 'sink'

    relations = []
    component_names_with_connections = set()

    for component_name, component in components.items():
        component['component_name'] = component

        if len(component.get('inputs', [])) > 0:
            for component_input in component['inputs']:
                if '*' not in component_input:
                    component_names_with_connections.add(component_input)
                    component_names_with_connections.add(component_name)
                    relations.append(f"{component_input} -> {component_name}")
                else:
                    for component_input_expanded in components.keys():
                        if fnmatch.fnmatch(component_input_expanded, component_input):
                            component_names_with_connections.add(component_input_expanded)
                            component_names_with_connections.add(component_name)
                            relations.append(f"{component_input_expanded} -> {component_name}")

    print("")
    component_names_with_connections = sorted(component_names_with_connections)

    for component_kind in ['source', 'transform', 'sink']:
        print(f"frame {component_kind}s" + " {")
        for component_name_with_connection in sorted(component_names_with_connections):
            if components[component_name_with_connection]['component_kind'] == component_kind:
                print(f"    component {component_name_with_connection}")
        print("}")
        print("")

    print("sources -[hidden]-> transforms")
    print("transforms -[hidden]-> sinks")
    print("")

    print("\n".join(relations))

    print("")
    print("@enduml")

if __name__ == '__main__':
    main()
